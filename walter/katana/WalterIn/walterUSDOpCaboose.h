// Copyright 2017 Rodeo FX.  All rights reserved.

#ifndef __WALTERUSDOPCABOOSE_H_
#define __WALTERUSDOPCABOOSE_H_

#include <pxr/usd/usd/prim.h>

#include "walterUSDOpIndex.h"

PXR_NAMESPACE_USING_DIRECTIVE

namespace OpUtils
{
class PrivateData;
}

/** @brief Everything related to the conversion from USD to Katana is here. At
 * the moment there is no reason to have an object, so we use the namespace. The
 * idea is not include Katana stuff in this header because in the future we
 * might be using this file for the Arnold prcedural.
 * P.S. Katana has the cook, we created the caboose for the cook.
 * P.P.S. Caboose:
 * 1. a railroad car with accommodations for the train crew, typically attached
 * to the end of the train.
 * 2. a kitchen on a ship's deck. */
namespace OpCaboose
{
/** @brief Represents an object that keeps a single attribute. And it can apply
 * this attribute to the client's object very fast. We keep the attribute as a
 * pointer to a function with pre-bound parameters. Since everything is already
 * bound, there are no precomputations, and the applying of the attribute should
 * be very fast. We don't use Katana Group builder directly because our code
 * should be client-agnostic, in the future, we will use the same code for
 * Arnold procedural. A client is a USD consumer (like Katana or Arnold). */
class ClientAttribute
{
public:
    /** @brief We apply attributes into this object. For Katana it's
     * GroupBuilder*, for Arnold, it's AtNode* */
    typedef void* Carrier;
    /** @brief We keep the attribute as a pointer to a function fith pre-bound
     * parameters. */
    typedef std::function<void(Carrier)> AttributeSetFn;
    typedef std::shared_ptr<AttributeSetFn> AttributeSetFnPtr;

    ClientAttribute(AttributeSetFnPtr iFunction) : mFunction(iFunction) {}

    /**
     * @brief Check if it's valid.
     *
     * @return True if valid.
     */
    bool valid() const { return mFunction != nullptr; }

    /**
     * @brief Applies the parameter to the clien's object.
     *
     * @param iCarrier
     */
    void evaluate(Carrier iCarrier) const;

private:
    AttributeSetFnPtr mFunction;
};

typedef std::shared_ptr<ClientAttribute> ClientAttributePtr;

/**
 * @brief Check if the prim is supported.
 *
 * @param prim The given prim.
 *
 * @return True if it's a supported privitive
 */
bool isSupported(const UsdPrim& iPrim);

/**
 * @brief Check if it's necessary to output children.
 *
 * @param prim The given prim.
 *
 * @return False if it's necessary to output children
 */
bool skipChildren(const UsdPrim& iPrim);

/**
 * @brief Output prim. We only support polymeshes
 *
 * @param iPrim The USD prim that is needed to output to the client.
 * @param iPrivateData The object that is generated by us for each node we
 * are going to produce.
 * @param ioClientData The data coming from the client (like Katana or Arnold in
 * the future) that is passed to the caboose. For Katana it's
 * GeolibCookInterface.
 */
void cook(
    const UsdPrim& iPrim,
    const OpUtils::PrivateData* iPrivateData,
    void* ioClientData);

/**
 * @brief Create Geolib children.
 *
 * @param iPrim The children of this USD prim will be created.
 * @param iPrivateData The object that is generated by us for each node we
 * are going to produce.
 * @param ioClientData The data coming from the client (like Katana or Arnold in
 * the future) that is passed to the caboose. For Katana it's
 * GeolibCookInterface.
 */
void cookChild(
    const UsdPrim& iPrim,
    const OpUtils::PrivateData* iPrivateData,
    void* ioClientData,
    std::string iCustomName = "");

/**
 * @brief Return an object that it's possible to use to output client parameter.
 * Basically, it converts UsdAttribute to Katana Attribute.
 *
 * @param iAttr UsdAttribute
 * @param iTime Time
 *
 * @retur Shared pointer to the client attribute.
 */
ClientAttributePtr createClientAttribute(
    const UsdAttribute& iAttr,
    UsdTimeCode iTime = UsdTimeCode::Default());
}

#endif
