// Copyright 2017 Rodeo FX.  All rights reserved.

#ifndef __WALTERUSDOPENGINE_H_
#define __WALTERUSDOPENGINE_H_

#include "walterUSDOpIndex.h"
#include "walterUSDCommonUtils.h"

#include <pxr/usd/sdf/path.h>
#include <pxr/usd/usd/stage.h>

PXR_NAMESPACE_USING_DIRECTIVE

namespace OpUtils
{
class PrivateData;
}

/** @brief The top-level entry point for rendering USD stage. We only have one
 * object per stage. And it should contain everything ralated to the stage. */
class OpEngine
{
public:
    /**
     * @brief Public constructor
     *
     * @param iArchives the list of archives.
     *
     * @return The engine.
     */
    static OpEngine& getInstance(const std::vector<std::string>& iArchives);

    /** @brief Remove all the cached OpEngine objects */
    static void clearCaches();

    /**
     * @brief Generate a scene graph node for the specified path.
     *
     * @param iPrivateData The object that is generated by us for each node we
     * are going to produce.
     * @param ioClientData The data came from the client (Katana) that should be
     * passed to the caboose. For Katana it's GeolibCookInterface.
     */
    void cook(const OpUtils::PrivateData* iPrivateData, void* ioClientData);

    /**
     * @brief Generate Masters location of a scene graph node if instances are
     * present. This function should be called once at the begining of a cook
     * process for a given "root" location.
     *
     * @param iPrivateData The object that is generated by us for each node we
     * are going to produce.
     * @param ioClientData The data came from the client (Katana) that should be
     * passed to the caboose. For Katana it's GeolibCookInterface.
     */
    void cookMasters(
        const OpUtils::PrivateData* iPrivateData,
        void* ioClientData);

    /**
     * @brief Sets scenes parameters before cooking.
     *
     * @param iPrivateData The object that is generated by us for each node we
     * are going to produce.
     * @param ioClientData The data came from the client (Katana) that should be
     * passed to the caboose. For Katana it's GeolibCookInterface.
     */
    void dress(void* ioClientData);

    OpIndex& index() { return mIndex; }

    /**
     * @brief Get the 'real' master name for the given primitive.
     *
     * @param iPrim The primitive for which to check an eventual related
     * master primitive and it's real name before it became instanciated.
     * @return The original master primitive name.
     */
    std::string getMasterName(const UsdPrim& iPrim);

    /**
     * @brief Get the 'real' master name for the given primitive.
     *
     * @param iPrim The primitive for which to check an eventual related
     * master primitive and it's real name before it became instanciated.
     * @return The original master primitive name.
     */
    std::string getKatMasterName(const UsdPrim& iMasterPrim);

    /**
     * @brief Returns the string enough to recreate the same engine in the
     * procedural.
     */
    const std::string& getIdentifier() const { return mIdentifier; }

    /**
     * @brief Returns the USD stage
     */
    UsdStageRefPtr getUsdStage() const { return mStage; }


private:
    friend class std::pair<const size_t, OpEngine>;

    // We need to be sure that this object can be created only by the registry.
    OpEngine(const std::vector<std::string>& iArchives);

    WalterUSDCommonUtils::MasterPrimInfo getMasterPrimInfo(
        const UsdPrim& iPrim);

    // Material assignments and the index data to fast access.
    OpIndex mIndex;

    // We keep the USD stage here, so once engine is destructed, the stage will
    // be automatically closed.
    UsdStageRefPtr mStage;

    // The string that can be used in the procedural.
    std::string mIdentifier;

    // Map master primitive name with the primitive name they refer.
    // This is used to handle assignement on instances.
    WalterUSDCommonUtils::MastersInfoMap mMastersInfoMap;
};

#endif
